// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nxos

import (
	"context"
	"reflect"

	"errors"
	"github.com/lbrlabs/pulumi-nxos/sdk/go/nxos/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// This resource can manage the queuing QoS policy map match class map remaining bandwidth configuration.
//
// - API Documentation: [ipqosSetRemBW](https://pubhub.devnetcloud.com/media/dme-docs-10-2-2/docs/Qos/ipqos:SetRemBW/)
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/lbrlabs/pulumi-nxos/sdk/go/nxos"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := nxos.NewQueuingQosPolicyMapMatchClassMapRemainingBandwidth(ctx, "example", &nxos.QueuingQosPolicyMapMatchClassMapRemainingBandwidthArgs{
//				ClassMapName:  pulumi.String("c-out-q1"),
//				PolicyMapName: pulumi.String("PM1"),
//				Value:         pulumi.Int(10),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import nxos:index/queuingQosPolicyMapMatchClassMapRemainingBandwidth:QueuingQosPolicyMapMatchClassMapRemainingBandwidth example "sys/ipqos/queuing/p/name-[PM1]/cmap-[c-out-q1]/setRemBW"
//
// ```
type QueuingQosPolicyMapMatchClassMapRemainingBandwidth struct {
	pulumi.CustomResourceState

	// Class map name.
	ClassMapName pulumi.StringOutput `pulumi:"classMapName"`
	// A device name from the provider configuration.
	Device pulumi.StringPtrOutput `pulumi:"device"`
	// Policy map name.
	PolicyMapName pulumi.StringOutput `pulumi:"policyMapName"`
	// Remaining bandwidth percent. - Range: `0`-`100`
	Value pulumi.IntOutput `pulumi:"value"`
}

// NewQueuingQosPolicyMapMatchClassMapRemainingBandwidth registers a new resource with the given unique name, arguments, and options.
func NewQueuingQosPolicyMapMatchClassMapRemainingBandwidth(ctx *pulumi.Context,
	name string, args *QueuingQosPolicyMapMatchClassMapRemainingBandwidthArgs, opts ...pulumi.ResourceOption) (*QueuingQosPolicyMapMatchClassMapRemainingBandwidth, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClassMapName == nil {
		return nil, errors.New("invalid value for required argument 'ClassMapName'")
	}
	if args.PolicyMapName == nil {
		return nil, errors.New("invalid value for required argument 'PolicyMapName'")
	}
	if args.Value == nil {
		return nil, errors.New("invalid value for required argument 'Value'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource QueuingQosPolicyMapMatchClassMapRemainingBandwidth
	err := ctx.RegisterResource("nxos:index/queuingQosPolicyMapMatchClassMapRemainingBandwidth:QueuingQosPolicyMapMatchClassMapRemainingBandwidth", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetQueuingQosPolicyMapMatchClassMapRemainingBandwidth gets an existing QueuingQosPolicyMapMatchClassMapRemainingBandwidth resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetQueuingQosPolicyMapMatchClassMapRemainingBandwidth(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *QueuingQosPolicyMapMatchClassMapRemainingBandwidthState, opts ...pulumi.ResourceOption) (*QueuingQosPolicyMapMatchClassMapRemainingBandwidth, error) {
	var resource QueuingQosPolicyMapMatchClassMapRemainingBandwidth
	err := ctx.ReadResource("nxos:index/queuingQosPolicyMapMatchClassMapRemainingBandwidth:QueuingQosPolicyMapMatchClassMapRemainingBandwidth", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering QueuingQosPolicyMapMatchClassMapRemainingBandwidth resources.
type queuingQosPolicyMapMatchClassMapRemainingBandwidthState struct {
	// Class map name.
	ClassMapName *string `pulumi:"classMapName"`
	// A device name from the provider configuration.
	Device *string `pulumi:"device"`
	// Policy map name.
	PolicyMapName *string `pulumi:"policyMapName"`
	// Remaining bandwidth percent. - Range: `0`-`100`
	Value *int `pulumi:"value"`
}

type QueuingQosPolicyMapMatchClassMapRemainingBandwidthState struct {
	// Class map name.
	ClassMapName pulumi.StringPtrInput
	// A device name from the provider configuration.
	Device pulumi.StringPtrInput
	// Policy map name.
	PolicyMapName pulumi.StringPtrInput
	// Remaining bandwidth percent. - Range: `0`-`100`
	Value pulumi.IntPtrInput
}

func (QueuingQosPolicyMapMatchClassMapRemainingBandwidthState) ElementType() reflect.Type {
	return reflect.TypeOf((*queuingQosPolicyMapMatchClassMapRemainingBandwidthState)(nil)).Elem()
}

type queuingQosPolicyMapMatchClassMapRemainingBandwidthArgs struct {
	// Class map name.
	ClassMapName string `pulumi:"classMapName"`
	// A device name from the provider configuration.
	Device *string `pulumi:"device"`
	// Policy map name.
	PolicyMapName string `pulumi:"policyMapName"`
	// Remaining bandwidth percent. - Range: `0`-`100`
	Value int `pulumi:"value"`
}

// The set of arguments for constructing a QueuingQosPolicyMapMatchClassMapRemainingBandwidth resource.
type QueuingQosPolicyMapMatchClassMapRemainingBandwidthArgs struct {
	// Class map name.
	ClassMapName pulumi.StringInput
	// A device name from the provider configuration.
	Device pulumi.StringPtrInput
	// Policy map name.
	PolicyMapName pulumi.StringInput
	// Remaining bandwidth percent. - Range: `0`-`100`
	Value pulumi.IntInput
}

func (QueuingQosPolicyMapMatchClassMapRemainingBandwidthArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*queuingQosPolicyMapMatchClassMapRemainingBandwidthArgs)(nil)).Elem()
}

type QueuingQosPolicyMapMatchClassMapRemainingBandwidthInput interface {
	pulumi.Input

	ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput
	ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthOutputWithContext(ctx context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput
}

func (*QueuingQosPolicyMapMatchClassMapRemainingBandwidth) ElementType() reflect.Type {
	return reflect.TypeOf((**QueuingQosPolicyMapMatchClassMapRemainingBandwidth)(nil)).Elem()
}

func (i *QueuingQosPolicyMapMatchClassMapRemainingBandwidth) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput {
	return i.ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthOutputWithContext(context.Background())
}

func (i *QueuingQosPolicyMapMatchClassMapRemainingBandwidth) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthOutputWithContext(ctx context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput)
}

func (i *QueuingQosPolicyMapMatchClassMapRemainingBandwidth) ToOutput(ctx context.Context) pulumix.Output[*QueuingQosPolicyMapMatchClassMapRemainingBandwidth] {
	return pulumix.Output[*QueuingQosPolicyMapMatchClassMapRemainingBandwidth]{
		OutputState: i.ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthOutputWithContext(ctx).OutputState,
	}
}

// QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayInput is an input type that accepts QueuingQosPolicyMapMatchClassMapRemainingBandwidthArray and QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput values.
// You can construct a concrete instance of `QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayInput` via:
//
//	QueuingQosPolicyMapMatchClassMapRemainingBandwidthArray{ QueuingQosPolicyMapMatchClassMapRemainingBandwidthArgs{...} }
type QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayInput interface {
	pulumi.Input

	ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput
	ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutputWithContext(context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput
}

type QueuingQosPolicyMapMatchClassMapRemainingBandwidthArray []QueuingQosPolicyMapMatchClassMapRemainingBandwidthInput

func (QueuingQosPolicyMapMatchClassMapRemainingBandwidthArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth)(nil)).Elem()
}

func (i QueuingQosPolicyMapMatchClassMapRemainingBandwidthArray) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput {
	return i.ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutputWithContext(context.Background())
}

func (i QueuingQosPolicyMapMatchClassMapRemainingBandwidthArray) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutputWithContext(ctx context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput)
}

func (i QueuingQosPolicyMapMatchClassMapRemainingBandwidthArray) ToOutput(ctx context.Context) pulumix.Output[[]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth] {
	return pulumix.Output[[]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth]{
		OutputState: i.ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutputWithContext(ctx).OutputState,
	}
}

// QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapInput is an input type that accepts QueuingQosPolicyMapMatchClassMapRemainingBandwidthMap and QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput values.
// You can construct a concrete instance of `QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapInput` via:
//
//	QueuingQosPolicyMapMatchClassMapRemainingBandwidthMap{ "key": QueuingQosPolicyMapMatchClassMapRemainingBandwidthArgs{...} }
type QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapInput interface {
	pulumi.Input

	ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput
	ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutputWithContext(context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput
}

type QueuingQosPolicyMapMatchClassMapRemainingBandwidthMap map[string]QueuingQosPolicyMapMatchClassMapRemainingBandwidthInput

func (QueuingQosPolicyMapMatchClassMapRemainingBandwidthMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth)(nil)).Elem()
}

func (i QueuingQosPolicyMapMatchClassMapRemainingBandwidthMap) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput {
	return i.ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutputWithContext(context.Background())
}

func (i QueuingQosPolicyMapMatchClassMapRemainingBandwidthMap) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutputWithContext(ctx context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput)
}

func (i QueuingQosPolicyMapMatchClassMapRemainingBandwidthMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth] {
	return pulumix.Output[map[string]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth]{
		OutputState: i.ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutputWithContext(ctx).OutputState,
	}
}

type QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput struct{ *pulumi.OutputState }

func (QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**QueuingQosPolicyMapMatchClassMapRemainingBandwidth)(nil)).Elem()
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput {
	return o
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthOutputWithContext(ctx context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput {
	return o
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput) ToOutput(ctx context.Context) pulumix.Output[*QueuingQosPolicyMapMatchClassMapRemainingBandwidth] {
	return pulumix.Output[*QueuingQosPolicyMapMatchClassMapRemainingBandwidth]{
		OutputState: o.OutputState,
	}
}

// Class map name.
func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput) ClassMapName() pulumi.StringOutput {
	return o.ApplyT(func(v *QueuingQosPolicyMapMatchClassMapRemainingBandwidth) pulumi.StringOutput { return v.ClassMapName }).(pulumi.StringOutput)
}

// A device name from the provider configuration.
func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *QueuingQosPolicyMapMatchClassMapRemainingBandwidth) pulumi.StringPtrOutput { return v.Device }).(pulumi.StringPtrOutput)
}

// Policy map name.
func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput) PolicyMapName() pulumi.StringOutput {
	return o.ApplyT(func(v *QueuingQosPolicyMapMatchClassMapRemainingBandwidth) pulumi.StringOutput {
		return v.PolicyMapName
	}).(pulumi.StringOutput)
}

// Remaining bandwidth percent. - Range: `0`-`100`
func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput) Value() pulumi.IntOutput {
	return o.ApplyT(func(v *QueuingQosPolicyMapMatchClassMapRemainingBandwidth) pulumi.IntOutput { return v.Value }).(pulumi.IntOutput)
}

type QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput struct{ *pulumi.OutputState }

func (QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth)(nil)).Elem()
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput {
	return o
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutputWithContext(ctx context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput {
	return o
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth] {
	return pulumix.Output[[]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth]{
		OutputState: o.OutputState,
	}
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput) Index(i pulumi.IntInput) QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *QueuingQosPolicyMapMatchClassMapRemainingBandwidth {
		return vs[0].([]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth)[vs[1].(int)]
	}).(QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput)
}

type QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput struct{ *pulumi.OutputState }

func (QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth)(nil)).Elem()
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput() QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput {
	return o
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput) ToQueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutputWithContext(ctx context.Context) QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput {
	return o
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth] {
	return pulumix.Output[map[string]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth]{
		OutputState: o.OutputState,
	}
}

func (o QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput) MapIndex(k pulumi.StringInput) QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *QueuingQosPolicyMapMatchClassMapRemainingBandwidth {
		return vs[0].(map[string]*QueuingQosPolicyMapMatchClassMapRemainingBandwidth)[vs[1].(string)]
	}).(QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*QueuingQosPolicyMapMatchClassMapRemainingBandwidthInput)(nil)).Elem(), &QueuingQosPolicyMapMatchClassMapRemainingBandwidth{})
	pulumi.RegisterInputType(reflect.TypeOf((*QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayInput)(nil)).Elem(), QueuingQosPolicyMapMatchClassMapRemainingBandwidthArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapInput)(nil)).Elem(), QueuingQosPolicyMapMatchClassMapRemainingBandwidthMap{})
	pulumi.RegisterOutputType(QueuingQosPolicyMapMatchClassMapRemainingBandwidthOutput{})
	pulumi.RegisterOutputType(QueuingQosPolicyMapMatchClassMapRemainingBandwidthArrayOutput{})
	pulumi.RegisterOutputType(QueuingQosPolicyMapMatchClassMapRemainingBandwidthMapOutput{})
}
